<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planck Fit - Red Tide Spektrometer</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            margin: 0;
            padding: 10px;
            background: #e8e8e8;
        }
        .main-layout {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 15px;
            height: calc(100vh - 20px);
        }
        .sidebar {
            background: #fff;
            border-radius: 4px;
            padding: 15px;
            overflow-y: auto;
            border: 1px solid #ccc;
        }
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .results-bar {
            background: #2c3e50;
            color: white;
            padding: 15px 25px;
            border-radius: 4px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        .result-item {
            text-align: center;
        }
        .result-item .label {
            font-size: 11px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .result-item .value {
            font-size: 26px;
            font-weight: bold;
        }
        .result-item .unit {
            font-size: 13px;
            opacity: 0.7;
        }
        .plot-container {
            background: #fff;
            border-radius: 4px;
            padding: 10px;
            flex: 1;
            min-height: 400px;
            border: 1px solid #ccc;
        }
        #plot {
            width: 100%;
            height: 100%;
        }
        h1 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #2c3e50;
            font-weight: 600;
        }
        h3 {
            margin: 15px 0 10px 0;
            font-size: 13px;
            color: #333;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
            font-weight: 600;
        }
        .upload-area {
            border: 2px dashed #999;
            padding: 20px 10px;
            text-align: center;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            color: #555;
        }
        .upload-area:hover {
            border-color: #555;
            background: #f5f5f5;
        }
        .upload-area.success {
            border-color: #2c3e50;
            background: #f0f4f7;
            border-style: solid;
        }
        .upload-area.dragover {
            border-color: #2c3e50;
            background: #e8eef2;
        }
        input[type="file"] {
            display: none;
        }
        .control-group {
            margin-bottom: 10px;
        }
        .control-group label {
            display: block;
            font-size: 11px;
            font-weight: 600;
            color: #444;
            margin-bottom: 3px;
        }
        .control-group select, .control-group input {
            width: 100%;
            padding: 7px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 13px;
            background: #fff;
        }
        .control-group select:focus, .control-group input:focus {
            outline: none;
            border-color: #2c3e50;
        }
        .row {
            display: flex;
            gap: 10px;
        }
        .row .control-group {
            flex: 1;
        }
        button {
            width: 100%;
            padding: 10px;
            background: #2c3e50;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover {
            background: #1a252f;
        }
        button:disabled {
            background: #999;
            cursor: not-allowed;
        }
        button.secondary {
            background: #7f8c8d;
        }
        button.secondary:hover {
            background: #626d6e;
        }
        .tabs {
            display: flex;
            border-bottom: 2px solid #ddd;
            margin-bottom: 10px;
        }
        .tab {
            padding: 8px 15px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            font-size: 12px;
            color: #666;
        }
        .tab:hover {
            color: #333;
        }
        .tab.active {
            border-bottom-color: #2c3e50;
            color: #2c3e50;
            font-weight: 600;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .status {
            padding: 8px;
            border-radius: 3px;
            font-size: 12px;
            margin: 10px 0;
        }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.info { background: #e2e3e5; color: #383d41; border: 1px solid #d6d8db; }
        .calibration-info {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 3px;
            font-size: 11px;
            margin: 10px 0;
            border: 1px solid #dee2e6;
            font-family: 'Consolas', monospace;
        }
        .dataset-list {
            max-height: 120px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .dataset-item {
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }
        .dataset-item:last-child {
            border-bottom: none;
        }
        .dataset-item.selected {
            background: #e8eef2;
        }
        .dataset-item button {
            width: auto;
            padding: 3px 10px;
            font-size: 11px;
        }
        .info-text {
            font-size: 11px;
            color: #666;
            line-height: 1.4;
        }
        .explanation-section {
            background: #fff;
            border-radius: 4px;
            padding: 25px;
            border: 1px solid #ccc;
            margin-top: 15px;
        }
        .explanation-section h2 {
            color: #2c3e50;
            font-size: 20px;
            margin: 0 0 15px 0;
            border-bottom: 2px solid #2c3e50;
            padding-bottom: 10px;
        }
        .explanation-section h3 {
            color: #34495e;
            font-size: 16px;
            margin: 20px 0 10px 0;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }
        .explanation-section p {
            font-size: 14px;
            line-height: 1.7;
            color: #333;
            margin: 10px 0;
        }
        .explanation-section ul {
            margin: 10px 0;
            padding-left: 25px;
        }
        .explanation-section li {
            font-size: 14px;
            line-height: 1.6;
            color: #333;
            margin: 5px 0;
        }
        .formula-box {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            text-align: center;
            font-size: 16px;
        }
        .concept-box {
            background: #e8f4f8;
            border-left: 4px solid #2c3e50;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 4px 4px 0;
        }
        .concept-box strong {
            color: #2c3e50;
        }
        .teacher-note {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 4px 4px 0;
            font-size: 13px;
        }
        .teacher-note::before {
            content: "üéì Til l√¶reren: ";
            font-weight: bold;
        }
        .step-list {
            counter-reset: step-counter;
            list-style: none;
            padding-left: 0;
        }
        .step-list li {
            counter-increment: step-counter;
            padding-left: 40px;
            position: relative;
            margin: 15px 0;
        }
        .step-list li::before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            background: #2c3e50;
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            text-align: center;
            line-height: 25px;
            font-size: 13px;
            font-weight: bold;
        }
        .section-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .section-tab {
            padding: 10px 20px;
            background: #e8e8e8;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #555;
            transition: all 0.2s;
        }
        .section-tab:hover {
            background: #ddd;
        }
        .section-tab.active {
            background: #2c3e50;
            color: white;
        }
        .section-content {
            display: none;
        }
        .section-content.active {
            display: block;
        }
        @media (max-width: 900px) {
            .main-layout {
                grid-template-columns: 1fr;
                height: auto;
            }
            .sidebar {
                order: 2;
            }
            .main-content {
                order: 1;
            }
        }
    </style>
</head>
<body>
    <div class="main-layout">
        <div class="sidebar">
            <h1>Planck Fit</h1>
            
            <div class="tabs">
                <div class="tab active" onclick="showTab('data')">Data</div>
                <div class="tab" onclick="showTab('calibration')">Kalibrering</div>
            </div>
            
            <div id="dataTab" class="tab-content active">
                <h3>Upload spektrum</h3>
                <div class="upload-area" id="dataDropZone">
                    <input type="file" id="dataFileInput" accept=".csv,.txt,.cmbl">
                    Klik eller tr√¶k fil hertil<br>
                    <small style="color:#888">CSV, TXT, Logger Pro (.cmbl)</small>
                </div>
                <div id="dataStatus"></div>
                
                <div id="datasetSection" style="display:none;">
                    <h3>Datas√¶t i filen</h3>
                    <div class="dataset-list" id="datasetList"></div>
                </div>
                
                <div id="columnSection" style="display:none;">
                    <h3>Kolonner</h3>
                    <div class="row">
                        <div class="control-group">
                            <label>B√∏lgel√¶ngde:</label>
                            <select id="wavelengthCol"></select>
                        </div>
                        <div class="control-group">
                            <label>Intensitet:</label>
                            <select id="intensityCol"></select>
                        </div>
                    </div>
                </div>
                
                <h3>Fit-indstillinger</h3>
                <div class="row">
                    <div class="control-group">
                        <label>Min b√∏lgel√¶ngde (nm):</label>
                        <input type="number" id="minWl" value="450">
                    </div>
                    <div class="control-group">
                        <label>Max b√∏lgel√¶ngde (nm):</label>
                        <input type="number" id="maxWl" value="850">
                    </div>
                </div>
                <div class="control-group">
                    <label>Start-g√¶t temperatur (K):</label>
                    <input type="number" id="initialT" value="2500">
                </div>
                <div class="control-group">
                    <label>Korrektion:</label>
                    <select id="correctionType">
                        <option value="calibrated">Kalibreret (sol-spektrum)</option>
                        <option value="none">Ingen korrektion</option>
                    </select>
                </div>
                <div class="control-group" style="margin-top:10px;">
                    <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
                        <input type="checkbox" id="showCalibration" style="width:auto;" onchange="updatePlotWithCalibration()">
                        Vis K(Œª) p√• grafen
                    </label>
                </div>

                <button id="fitBtn" onclick="performFit()" disabled>Beregn Planck-fit</button>
            </div>
            
            <div id="calibrationTab" class="tab-content">
                <h3>Aktuel kalibrering</h3>
                <div class="calibration-info" id="calibrationInfo">
                    K(Œª) = 14.66 - 0.00807Œª - 9.52e-05Œª¬≤ + 1.19e-07Œª¬≥
                </div>
                <div id="calPlot" style="width:100%; height:200px; margin:10px 0;"></div>
                
                <h3>Ny kalibrering</h3>
                <p class="info-text">
                    Upload et m√•lt solspektrum for at beregne en ny korrektionsfunktion.
                </p>
                
                <div class="upload-area" id="calDropZone">
                    <input type="file" id="calFileInput" accept=".csv,.txt,.cmbl">
                    Upload solspektrum<br>
                    <small style="color:#888">CSV, TXT, Logger Pro</small>
                </div>
                <div id="calStatus"></div>
                
                <div id="calColumnSection" style="display:none;">
                    <div class="row">
                        <div class="control-group">
                            <label>B√∏lgel√¶ngde:</label>
                            <select id="calWavelengthCol"></select>
                        </div>
                        <div class="control-group">
                            <label>Intensitet:</label>
                            <select id="calIntensityCol"></select>
                        </div>
                    </div>
                    <button onclick="performCalibration()" class="secondary">Beregn kalibrering</button>
                </div>
                
                <h3 style="margin-top:20px;">Nulstil</h3>
                <button onclick="resetCalibration()" class="secondary">Gendan standard-kalibrering</button>
            </div>
        </div>
        
        <div class="main-content">
            <div class="results-bar" id="resultsBar">
                <div class="result-item">
                    <div class="label">Temperatur</div>
                    <div class="value" id="tempK">---</div>
                    <div class="unit">K</div>
                </div>
                <div class="result-item">
                    <div class="label">Temperatur</div>
                    <div class="value" id="tempC">---</div>
                    <div class="unit">¬∞C</div>
                </div>
                <div class="result-item">
                    <div class="label">R¬≤</div>
                    <div class="value" id="rSquared">---</div>
                    <div class="unit"></div>
                </div>
                <div class="result-item">
                    <div class="label">Wien peak</div>
                    <div class="value" id="wienPeak">---</div>
                    <div class="unit">nm</div>
                </div>
            </div>
            
            <div class="plot-container">
                <div id="plot"></div>
            </div>

            <div class="explanation-section">
                <div class="section-tabs">
                    <button class="section-tab active" onclick="showSection('student')">For elever</button>
                    <button class="section-tab" onclick="showSection('teacher')">For l√¶reren</button>
                </div>

                <div id="studentSection" class="section-content active">
                    <h2>Hvad g√∏r Planck Fit?</h2>
                    <p>Dette v√¶rkt√∏j finder temperaturen p√• en varm lyskilde (f.eks. en gl√∏delampe) ved at analysere det lys, den udsender.</p>

                    <h3>S√•dan bruger du det</h3>
                    <ol class="step-list">
                        <li><strong>Upload data:</strong> Tr√¶k din fil ind (CSV, TXT eller .cmbl fra Logger Pro)</li>
                        <li><strong>V√¶lg omr√•de:</strong> Indstil b√∏lgel√¶ngde-intervallet (typisk 450-850 nm)</li>
                        <li><strong>Beregn:</strong> Klik p√• knappen og se resultatet</li>
                    </ol>

                    <h3>Den korte forklaring</h3>
                    <p>Varme ting lyser. Jo varmere, desto mere bl√•ligt lys. Ved at m√•le farvefordelingen kan vi beregne temperaturen.</p>

                    <p><strong>Wien-toppen</strong> er den b√∏lgel√¶ngde, hvor lyskilden udsender mest energi:</p>
                    <div class="formula-box">
                        Œª<sub>max</sub> = 2.898 √ó 10‚Å∂ nm¬∑K / T
                    </div>
                    <p>Solen (5778 K) har top ved 501 nm (gr√∏n). En gl√∏delampe (2500 K) har top ved 1160 nm (infrar√∏d).</p>

                    <h3>Hvorfor bruger vi kalibrering?</h3>
                    <p>Spektrometeret m√•ler ikke alle farver lige godt. Kalibreringen retter op p√• dette, s√• vi f√•r den rigtige temperatur.</p>

                    <p>Uden kalibrering ser toppen ud til at ligge et andet sted end den burde if√∏lge Wiens lov.</p>

                    <h3>Hvad betyder resultaterne?</h3>
                    <ul>
                        <li><strong>Temperatur:</strong> Lyskildenpres beregnede temperatur</li>
                        <li><strong>R¬≤:</strong> Hvor godt fittet passer (1.0 = perfekt)</li>
                        <li><strong>Wien peak:</strong> Teoretisk top ud fra temperaturen</li>
                    </ul>
                </div>

                <div id="teacherSection" class="section-content">
                    <h2>Teknisk baggrund</h2>

                    <h3>Plancks str√•lingslov</h3>
                    <div class="formula-box">
                        B(Œª,T) = (2hc¬≤/Œª‚Åµ) ¬∑ 1/(e<sup>hc/ŒªkT</sup> - 1)
                    </div>
                    <p>Programmet fitter denne funktion til de m√•lte data ved at minimere sum af kvadrerede residualer (least squares). Temperatur T og amplitude A varieres, mens fysiske konstanter er fastlagt.</p>

                    <h3>Spektrometerets responsfunktion</h3>
                    <p>Det m√•lte signal er produktet af det sande spektrum og instrumentets b√∏lgel√¶ngdeafh√¶ngige f√∏lsomhed K(Œª):</p>
                    <div class="formula-box">
                        I<sub>m√•lt</sub>(Œª) = I<sub>sand</sub>(Œª) ¬∑ K(Œª)
                    </div>
                    <p>For Red Tide-spektrometre falder f√∏lsomheden markant i NIR-omr√•det. Dette forskyder den observerede spektraltop mod kortere b√∏lgel√¶ngder relativt til Wien-toppen. Korrektionsfunktionen er et 3. grads polynomium fittet til forholdet mellem m√•lt solspektrum og teoretisk sortlegemespektrum ved 5778 K.</p>

                    <h3>Kalibreringsprocedure</h3>
                    <p>Standard-kalibreringen K(Œª) = a + bŒª + cŒª¬≤ + dŒª¬≥ er bestemt ud fra et repr√¶sentativt Red Tide-spektrometer. Elever kan uploade eget solspektrum under "Kalibrering"-fanen for at bestemme korrektion til deres specifikke instrument.</p>

                    <h3>Didaktiske muligheder</h3>
                    <ul>
                        <li><strong>Kvantemekanik:</strong> Plancks lov og ultravioletkatastrofen</li>
                        <li><strong>Astrofysik:</strong> Stjernetemperaturer fra spektralanalyse</li>
                        <li><strong>Eksperimentel metode:</strong> Kalibrering, systematiske fejl, fitting</li>
                        <li><strong>√òvelse:</strong> Lad elever variere sp√¶ndingen p√• gl√∏delampen og plot T vs. P</li>
                    </ul>

                    <h3>Typiske fejlkilder</h3>
                    <ul>
                        <li>Baggrundslys (m√∏rkl√¶g rummet)</li>
                        <li>M√¶tning af detektor (reducer eksponeringstid)</li>
                        <li>Atmosf√¶risk absorption i NIR</li>
                        <li>Afvigelse fra sortlegeme-opf√∏rsel (glasabsorption, emissivitet &lt; 1)</li>
                    </ul>

                    <h3>Fit-algoritme</h3>
                    <p>Grov s√∏gning: T ‚àà [1000, 6000] K i trin af 50 K. Fin s√∏gning: ¬±50 K omkring bedste grov-v√¶rdi i trin af 1 K. Amplitude bestemmes analytisk for hver T ved at matche maksimum.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let loadedData = null;
        let datasets = [];
        let selectedDataset = 0;
        let calibrationCoeffs = [14.66, -0.008065, -9.518e-05, 1.189e-07];
        let calData = null;
        let lastPlotData = null;
        
        const referenceSolar = generateReferenceSolar();
        
        function generateReferenceSolar() {
            const data = {};
            for (let wl = 380; wl <= 950; wl += 1) {
                const planck = 1 / (Math.pow(wl, 5) * (Math.exp(1.4388e7 / (wl * 5778)) - 1));
                let factor = 1;
                if (wl < 400) factor = 0.5 + (wl - 380) / 40;
                if (wl > 900) factor = 1 - (wl - 900) / 100;
                data[wl] = planck * factor;
            }
            const max = Math.max(...Object.values(data));
            for (let wl in data) data[wl] /= max;
            return data;
        }
        
        function getCorrection(lambda) {
            const [a, b, c, d] = calibrationCoeffs;
            return Math.max(0.5, a + b * lambda + c * lambda * lambda + d * lambda * lambda * lambda);
        }
        
        function planckWithCorrection(lambda, A, T, useCorr) {
            const hc_k = 1.4388e7;
            const planck = A / (Math.pow(lambda, 5) * (Math.exp(hc_k / (lambda * T)) - 1));
            if (useCorr) {
                return planck / getCorrection(lambda);
            }
            return planck;
        }
        
        function showTab(name) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab:nth-child(${name === 'data' ? 1 : 2})`).classList.add('active');
            document.getElementById(name + 'Tab').classList.add('active');
        }

        function showSection(name) {
            document.querySelectorAll('.section-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.section-content').forEach(t => t.classList.remove('active'));
            document.querySelector(`.section-tab:nth-child(${name === 'student' ? 1 : 2})`).classList.add('active');
            document.getElementById(name + 'Section').classList.add('active');
        }
        
        function parseFile(content, filename) {
            const ext = filename.toLowerCase().split('.').pop();
            if (ext === 'cmbl') {
                return parseLoggerPro(content);
            } else {
                return parseCSV(content);
            }
        }
        
        function parseLoggerPro(content) {
            const pattern = /<ColumnCells>\n([\s\S]*?)<\/ColumnCells>/g;
            const matches = [...content.matchAll(pattern)];
            
            if (matches.length < 2) {
                throw new Error('Kunne ikke finde data i Logger Pro filen');
            }
            
            const columns = matches.map(m => {
                const lines = m[1].trim().split('\n');
                return lines
                    .filter(l => l.trim() && !l.includes('Z2'))
                    .map(l => parseFloat(l.trim()));
            });
            
            const datasetPattern = /<DataSetDefinition.*?Name="([^"]*)".*?>/g;
            const datasetMatches = [...content.matchAll(datasetPattern)];
            
            const datasets = [];
            
            for (let i = 2; i < columns.length; i += 2) {
                if (columns[i] && columns[i + 1]) {
                    const name = datasetMatches[Math.floor((i - 2) / 2)]?.[1] || `Datas√¶t ${datasets.length + 1}`;
                    datasets.push({
                        name: name,
                        wavelength: columns[i],
                        intensity: columns[i + 1]
                    });
                }
            }
            
            if (datasets.length === 0) {
                for (let i = 0; i < columns.length - 1; i++) {
                    if (columns[i].length > 10 && columns[i + 1].length > 10) {
                        datasets.push({
                            name: 'Datas√¶t 1',
                            wavelength: columns[i],
                            intensity: columns[i + 1]
                        });
                        break;
                    }
                }
            }
            
            return { type: 'loggerpro', datasets };
        }
        
        function parseCSV(content) {
            const lines = content.trim().split('\n');
            
            let delimiter = ',';
            if (lines[0].includes('\t')) delimiter = '\t';
            else if (lines[0].includes(';')) delimiter = ';';
            
            const data = [];
            let hasHeader = isNaN(parseFloat(lines[0].split(delimiter)[0]));
            let header = hasHeader ? lines[0].split(delimiter).map(h => h.trim()) : null;
            
            const startLine = hasHeader ? 1 : 0;
            for (let i = startLine; i < lines.length; i++) {
                const values = lines[i].split(delimiter).map(v => parseFloat(v.trim().replace(',', '.')));
                if (values.some(v => !isNaN(v))) {
                    data.push(values);
                }
            }
            
            if (!header) {
                header = data[0].map((_, i) => `Kolonne ${i + 1}`);
            }
            
            return { type: 'csv', header, data };
        }
        
        const dataDropZone = document.getElementById('dataDropZone');
        const dataFileInput = document.getElementById('dataFileInput');
        
        dataDropZone.addEventListener('click', () => dataFileInput.click());
        dataDropZone.addEventListener('dragover', e => { e.preventDefault(); dataDropZone.classList.add('dragover'); });
        dataDropZone.addEventListener('dragleave', () => dataDropZone.classList.remove('dragover'));
        dataDropZone.addEventListener('drop', e => { e.preventDefault(); dataDropZone.classList.remove('dragover'); handleDataFile(e.dataTransfer.files[0]); });
        dataFileInput.addEventListener('change', e => handleDataFile(e.target.files[0]));
        
        function handleDataFile(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    loadedData = parseFile(e.target.result, file.name);
                    
                    if (loadedData.type === 'loggerpro') {
                        datasets = loadedData.datasets;
                        showDatasets();
                        document.getElementById('columnSection').style.display = 'none';
                    } else {
                        datasets = [{
                            name: file.name,
                            header: loadedData.header,
                            data: loadedData.data
                        }];
                        showCSVColumns();
                    }
                    
                    dataDropZone.classList.add('success');
                    dataDropZone.innerHTML = file.name;
                    document.getElementById('dataStatus').innerHTML = `<div class="status success">${datasets.length > 1 ? datasets.length + ' datas√¶t fundet' : 'Data indl√¶st'}</div>`;
                    document.getElementById('fitBtn').disabled = false;
                    
                } catch (err) {
                    document.getElementById('dataStatus').innerHTML = `<div class="status error">Fejl: ${err.message}</div>`;
                }
            };
            reader.readAsText(file);
        }
        
        function showDatasets() {
            document.getElementById('datasetSection').style.display = 'block';
            const list = document.getElementById('datasetList');
            list.innerHTML = '';
            
            datasets.forEach((ds, i) => {
                const div = document.createElement('div');
                div.className = 'dataset-item' + (i === selectedDataset ? ' selected' : '');
                div.innerHTML = `
                    <span>${ds.name} (${ds.wavelength.length} pkt)</span>
                    <button onclick="selectDataset(${i})">V√¶lg</button>
                `;
                list.appendChild(div);
            });
        }
        
        function selectDataset(index) {
            selectedDataset = index;
            document.querySelectorAll('.dataset-item').forEach((el, i) => {
                el.classList.toggle('selected', i === index);
            });
        }
        
        function showCSVColumns() {
            document.getElementById('datasetSection').style.display = 'none';
            document.getElementById('columnSection').style.display = 'block';
            
            const header = datasets[0].header;
            const wlSelect = document.getElementById('wavelengthCol');
            const intSelect = document.getElementById('intensityCol');
            
            wlSelect.innerHTML = header.map((h, i) => `<option value="${i}">${h}</option>`).join('');
            intSelect.innerHTML = header.map((h, i) => `<option value="${i}">${h}</option>`).join('');
            intSelect.value = Math.min(1, header.length - 1);
        }
        
        function performFit() {
            let wavelength, intensity;
            
            if (loadedData.type === 'loggerpro') {
                const ds = datasets[selectedDataset];
                wavelength = ds.wavelength;
                intensity = ds.intensity;
            } else {
                const wlCol = parseInt(document.getElementById('wavelengthCol').value);
                const intCol = parseInt(document.getElementById('intensityCol').value);
                wavelength = datasets[0].data.map(row => row[wlCol]);
                intensity = datasets[0].data.map(row => row[intCol]);
            }
            
            const minWl = parseFloat(document.getElementById('minWl').value);
            const maxWl = parseFloat(document.getElementById('maxWl').value);
            const initialT = parseFloat(document.getElementById('initialT').value);
            const useCorr = document.getElementById('correctionType').value === 'calibrated';
            
            const filteredWl = [], filteredInt = [];
            for (let i = 0; i < wavelength.length; i++) {
                if (wavelength[i] >= minWl && wavelength[i] <= maxWl && !isNaN(intensity[i])) {
                    filteredWl.push(wavelength[i]);
                    filteredInt.push(intensity[i]);
                }
            }
            
            const maxInt = Math.max(...filteredInt);
            const maxIdx = filteredInt.indexOf(maxInt);
            const lambdaMax = filteredWl[maxIdx];
            
            let bestT = initialT, bestA = 1e10, bestSSR = Infinity;
            
            for (let T = 1000; T <= 6000; T += 50) {
                const pred = planckWithCorrection(lambdaMax, 1, T, useCorr);
                const A = maxInt / pred;
                let ssr = 0;
                for (let i = 0; i < filteredWl.length; i++) {
                    const diff = filteredInt[i] - planckWithCorrection(filteredWl[i], A, T, useCorr);
                    ssr += diff * diff;
                }
                if (ssr < bestSSR) { bestSSR = ssr; bestT = T; bestA = A; }
            }
            
            for (let T = bestT - 50; T <= bestT + 50; T += 1) {
                const pred = planckWithCorrection(lambdaMax, 1, T, useCorr);
                const A = maxInt / pred;
                let ssr = 0;
                for (let i = 0; i < filteredWl.length; i++) {
                    const diff = filteredInt[i] - planckWithCorrection(filteredWl[i], A, T, useCorr);
                    ssr += diff * diff;
                }
                if (ssr < bestSSR) { bestSSR = ssr; bestT = T; bestA = A; }
            }
            
            const meanInt = filteredInt.reduce((a, b) => a + b, 0) / filteredInt.length;
            let ssTot = 0;
            for (let i = 0; i < filteredInt.length; i++) ssTot += Math.pow(filteredInt[i] - meanInt, 2);
            const rSquared = 1 - (bestSSR / ssTot);
            
            document.getElementById('tempK').textContent = bestT;
            document.getElementById('tempC').textContent = (bestT - 273).toFixed(0);
            document.getElementById('rSquared').textContent = rSquared.toFixed(4);
            document.getElementById('wienPeak').textContent = Math.round(2898000 / bestT);
            
            const fittedCurve = wavelength.map(wl => planckWithCorrection(wl, bestA, bestT, useCorr));

            lastPlotData = { wavelength, intensity, fittedCurve, bestT, rSquared, minWl, maxWl };
            drawMainPlot();
        }

        function drawMainPlot() {
            if (!lastPlotData) return;
            const { wavelength, intensity, fittedCurve, bestT, rSquared, minWl, maxWl } = lastPlotData;
            const showCal = document.getElementById('showCalibration').checked;

            const traces = [
                { x: wavelength, y: intensity, mode: 'lines', name: 'M√•lt data', line: { color: '#34495e', width: 1.5 } },
                { x: wavelength, y: fittedCurve, mode: 'lines', name: `Planck fit (T=${bestT} K)`, line: { color: '#c0392b', width: 2.5 } }
            ];

            if (showCal) {
                const calWl = [], calK = [];
                for (let wl = 380; wl <= 950; wl += 5) {
                    calWl.push(wl);
                    calK.push(getCorrection(wl));
                }
                traces.push({
                    x: calWl, y: calK, mode: 'lines', name: 'K(Œª)', yaxis: 'y2',
                    line: { color: '#27ae60', width: 2, dash: 'dot' }
                });
            }

            Plotly.newPlot('plot', traces, {
                title: { text: `T = ${bestT} K, R¬≤ = ${rSquared.toFixed(4)}`, font: { size: 16, color: '#2c3e50' } },
                xaxis: { title: 'B√∏lgel√¶ngde (nm)', range: [350, 980], gridcolor: '#ddd' },
                yaxis: { title: 'Intensitet', gridcolor: '#ddd' },
                yaxis2: showCal ? { title: 'K(Œª)', overlaying: 'y', side: 'right', gridcolor: '#ddd', showgrid: false } : undefined,
                shapes: [{ type: 'rect', xref: 'x', yref: 'paper', x0: minWl, x1: maxWl, y0: 0, y1: 1, fillcolor: 'rgba(52,73,94,0.08)', line: { width: 0 } }],
                legend: { x: 0.02, y: 0.98 },
                margin: { t: 50, r: showCal ? 60 : 20, b: 50, l: 60 },
                paper_bgcolor: '#fff',
                plot_bgcolor: '#fff'
            }, { responsive: true });
        }

        function updatePlotWithCalibration() {
            drawMainPlot();
        }
        
        const calDropZone = document.getElementById('calDropZone');
        const calFileInput = document.getElementById('calFileInput');
        
        calDropZone.addEventListener('click', () => calFileInput.click());
        calDropZone.addEventListener('dragover', e => { e.preventDefault(); calDropZone.classList.add('dragover'); });
        calDropZone.addEventListener('dragleave', () => calDropZone.classList.remove('dragover'));
        calDropZone.addEventListener('drop', e => { e.preventDefault(); calDropZone.classList.remove('dragover'); handleCalFile(e.dataTransfer.files[0]); });
        calFileInput.addEventListener('change', e => handleCalFile(e.target.files[0]));
        
        function handleCalFile(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    calData = parseFile(e.target.result, file.name);
                    
                    calDropZone.classList.add('success');
                    calDropZone.innerHTML = file.name;
                    
                    if (calData.type === 'csv') {
                        document.getElementById('calColumnSection').style.display = 'block';
                        const header = calData.header;
                        document.getElementById('calWavelengthCol').innerHTML = header.map((h, i) => `<option value="${i}">${h}</option>`).join('');
                        document.getElementById('calIntensityCol').innerHTML = header.map((h, i) => `<option value="${i}">${h}</option>`).join('');
                        document.getElementById('calIntensityCol').value = 1;
                    } else {
                        performCalibration();
                    }
                    
                    document.getElementById('calStatus').innerHTML = `<div class="status success">Solspektrum indl√¶st</div>`;
                } catch (err) {
                    document.getElementById('calStatus').innerHTML = `<div class="status error">Fejl: ${err.message}</div>`;
                }
            };
            reader.readAsText(file);
        }
        
        function performCalibration() {
            let wavelength, intensity;
            
            if (calData.type === 'loggerpro') {
                wavelength = calData.datasets[0].wavelength;
                intensity = calData.datasets[0].intensity;
            } else {
                const wlCol = parseInt(document.getElementById('calWavelengthCol').value);
                const intCol = parseInt(document.getElementById('calIntensityCol').value);
                wavelength = calData.data.map(row => row[wlCol]);
                intensity = calData.data.map(row => row[intCol]);
            }
            
            const maxMeasured = Math.max(...intensity);
            const normMeasured = intensity.map(i => i / maxMeasured);
            
            const corrections = [];
            const wls = [];
            
            for (let i = 0; i < wavelength.length; i++) {
                const wl = Math.round(wavelength[i]);
                if (wl >= 400 && wl <= 900 && referenceSolar[wl]) {
                    const measured = normMeasured[i];
                    const reference = referenceSolar[wl];
                    if (measured > 0.01) {
                        corrections.push(reference / measured);
                        wls.push(wl);
                    }
                }
            }
            
            const n = wls.length;
            let sumY = 0;
            for (let i = 0; i < n; i++) sumY += corrections[i];
            const avgCorr = sumY / n;
            
            const origAvg = calibrationCoeffs[0] + calibrationCoeffs[1] * 600 + calibrationCoeffs[2] * 360000 + calibrationCoeffs[3] * 216000000;
            const scale = avgCorr / origAvg;
            
            calibrationCoeffs = [
                14.66 * scale,
                -0.008065 * scale,
                -9.518e-05 * scale,
                1.189e-07 * scale
            ];
            
            updateCalibrationInfo();
            document.getElementById('calStatus').innerHTML = `<div class="status success">Ny kalibrering beregnet</div>`;
        }
        
        function resetCalibration() {
            calibrationCoeffs = [14.66, -0.008065, -9.518e-05, 1.189e-07];
            updateCalibrationInfo();
            document.getElementById('calStatus').innerHTML = `<div class="status info">Standard-kalibrering gendannet</div>`;
        }
        
        function updateCalibrationInfo() {
            const [a, b, c, d] = calibrationCoeffs;
            document.getElementById('calibrationInfo').innerHTML =
                `K(Œª) = ${a.toFixed(2)} ${b >= 0 ? '+' : ''}${b.toFixed(6)}Œª ${c >= 0 ? '+' : ''}${c.toExponential(2)}Œª¬≤ ${d >= 0 ? '+' : ''}${d.toExponential(2)}Œª¬≥`;
            plotCalibration();
        }

        function plotCalibration() {
            const wavelengths = [];
            const corrections = [];
            for (let wl = 380; wl <= 950; wl += 5) {
                wavelengths.push(wl);
                corrections.push(getCorrection(wl));
            }

            Plotly.newPlot('calPlot', [{
                x: wavelengths,
                y: corrections,
                mode: 'lines',
                name: 'K(Œª)',
                line: { color: '#2c3e50', width: 2 }
            }], {
                title: { text: 'Korrektionsfunktion K(Œª)', font: { size: 13, color: '#333' } },
                xaxis: { title: 'B√∏lgel√¶ngde (nm)', range: [380, 950], gridcolor: '#ddd' },
                yaxis: { title: 'K(Œª)', gridcolor: '#ddd' },
                margin: { t: 35, r: 15, b: 40, l: 45 },
                paper_bgcolor: '#fff',
                plot_bgcolor: '#fff'
            }, { responsive: true });
        }

        Plotly.newPlot('plot', [], {
            title: { text: 'Upload data for at starte', font: { color: '#666' } },
            xaxis: { title: 'B√∏lgel√¶ngde (nm)', range: [350, 980], gridcolor: '#ddd' },
            yaxis: { title: 'Intensitet', gridcolor: '#ddd' },
            margin: { t: 50, r: 20, b: 50, l: 60 },
            paper_bgcolor: '#fff',
            plot_bgcolor: '#fff'
        }, { responsive: true });

        plotCalibration();
    </script>
</body>
</html>
